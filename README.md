## 第2章　単一責任のクラスを設計する
- メソッドをグループに分けてクラスにまとめる
  - クラスベースのオブジェクト指向言語ではメソッドはクラス内に定義される
  - PJの初期段階では正しくグループ分けすることはできないもの
  - 変更が必要な日が来たときに変更できるかどうかはアプリケーションの設計によって行きまる
  - 設計とはアプリケーションの可変性を保つために技巧を凝らすこと、決して完璧を目指すための行為ではない
- 変更が簡単なようにコードを組成する
  - 簡単という概念は以下の定義
    - 変更は副作用をもたらさない
    - 変更の要件が小さければコードの変更も相応して小さい
    - 既存のコードは簡単に再利用できる
    - 最も簡単な変更方法はコードの追加、追加するコードはそれ自体が変更することが容易なもの
  - 各コードには次の性質が伴うべき
    - 見通しが良い(Transparent)
      - 変更がもたらす影響が明白
    - 合理性(Reasonable)
      - かかるコストは変更がもたらす利益に相応しい
    - 利用性が高い(Usable)
      - 新しい環境、予期していなかった環境でも再利用可能
    - 模範的(Examplary)
      - コードに変更を加える人が品質を自然と保つようなコードになっている
  - これらの性質を兼ね備えたコードは今現時点でのニーズを満たすだけでなく、将来的なニーズを満たすように変更を加えることが可能
- なぜ単一責任が重要なのか?
  - 変更が簡単なアプリケーションは再利用が簡単なクラスから構成されており、必要な部品だけを選んで組み立てることができる
  - 一方で2つ以上の責任を持つクラスは、責任が互いに結合しすぎてしまうため、簡単に再利用することが難しい
  - クラスが実際に何をしているかを定めるためには1文でクラスについて説明することであり、もし「それと」という言葉が含まれているのであればそれは2つ以上の責任を負っていることになる
  - 「今何もしないことの将来的なコストはどれくらいだろうか？」と自問自答し、現時点での要件と未来の可能性の相互間のトレードオフを理解すること、そしてコストが最小になる決断を下すことが重要
- 変更を歓迎するコードを書くために
  - データではなく振る舞いに依存する
    - インスタンス変数を隠蔽する
      - Rubyで言えばattr_reader等で隠蔽できる
      - そうすることで直接インスタンス変数を参照するよりもDRYなコードにできる（多くの箇所を変更する必要はない）
      - 隠蔽することによって予期せぬ変更がコード影響を与えることを防ぐ
    - データ構造を隠蔽する
      - インスタンス変数が複雑なデータ構造を含んでいる場合、インスタンス変数を隠蔽するだけでは不十分
      - 何かしようとした時に、何のデータが複雑なデータ構造の、どこのインデックスにあるかを知っている必要がある
        - 配列の構造が変わったり、ハッシュに変わったりすると、これを使用している箇所から全体にバグを生んでしまう
      - RubyではStructクラスを使うことで構造を包み隠すことができるため、複雑なデータ構造に関する知識は別メソッドに逃すことで、外部データの構造変更に強くなる + コードの可読性も上がる
- あらゆる箇所を単一責任にする
  - メソッドもクラスのように単一責任巣しておくことで、メソッドの変更も再利用も簡単にすることができる
  - メソッドが単一の責任を持つようにすることで、、
    - 隠蔽されていた性質を明らかにする
    - コメントをする必要がない
    - 再利用を促進する
    - 他のクラスへの移動が簡単

## 第3章　依存関係を管理する
- 適切に設計されたオブジェクトは単一の責任を持つため、複雑な問題を解決するためには共同作業をする必要がある
- これは非常に強力である一方で、他のオブジェクトを知っていなければならないというある種、依存のような危険を孕んでいる
- 2つのオブジェクトの結合が強固な時、それはあたかも1つのユニットであるかのように振る舞い、その内から1つだけ再利用することは不可能になる
- 疎結合なコードを書くこと
  - 依存オブジェクトの注入
    - 他のクラスにクラス名そのもので参照している箇所、すなわち別クラスを生成している箇所は結合を生み出す可能性が高い
    - クラス名が変わったらそのクラスを使用している箇所のクラス名も同様に変更せねばならない
    - クラス名を変えるだけであれば簡単だが、そのクラスを使っているクラス内で特定のメソッドを呼び出している場合、それは「AクラスはBクラスのみが特定のメソッドを返す」ということを意味していることになる
    - Aクラスは単にその特定のメソッドを呼び出せるオブジェクトが欲しいだけなので、Bクラスのインスタンス生成をAクラス内で行わないようにすることで結合が切り離される
      - `Hoge.new('hoge', 'hoge', Fuga.new('fuga', 'fuga')).method`的な
  - 依存を隔離する
    - インスタンス変数の隔離
      - 外部クラスのインスタンス変数を作成するときはそれ専用のメソッドを定義して、そのメソッド内でインスタンスを作成する
      - そうすることで外部クラスの参照を隔離できる
    - 脆いメソッドを隔離する
      - 外部メソッドとはself以外に送られるメソッドのこと
      - 他クラスのオブジェクトに対してのみ送れるメソッドがある場合（`hoge.method`みたいなの）、それは一種の依存となってしまい、何かを変更するたびに壊れる可能性がある
      - そのため、外部的な依存を取り除くために、別の専用メソッドに切り出してカプセル化するのが有効
  - 引数の順番への依存を取り除く
    - 引数は特定の固定された順番で渡してあげる必要があるが、これを正しい順番で渡さないとバグを生んでしまう
    - 初期化の際にハッシュを使うことで、引数をargsで受け取り、`args[:hoge]`のように取り出すことで引数の順番に対する依存を除去できる
    - もしくは明示的にデフォルト値を設定することでも依存を除去できる
- 依存方向の管理
  - コードに関する3つの事実
    - あるクラスは、他のクラスよりも要件が変わりやすい
    - 具象クラスは抽象クラスよりも変わる可能性が高い
    - 多くのところから依存されたクラスを変更すると、広範囲に影響が及ぶ
  - 依存されている数と要件が変わる可能性のマトリクス
    - A: 変更は起こりにくいが、広範囲に影響を及ぼす
    - B: 変更は起こりにくく、副作用もわずかしかない
    - C: 変更は起こりやすいが副作用はわずかしかない
    - D: 変更は起こる、そして変更はそこに依存するものに伝わっていく
  - 領域Dのクラスは多くの依存を持ち、アプリケーションの危険な箇所となる
  - 大量の依存を持つ具象クラスもまた、領域Dに分布するかもしれない
  - 開発をする際、どのクラスがどこにいくのか、依存度はどれくらいか、変更の可能性はどれくらいあるのか、自分より変更されないものに依存するようにする、ということを考えるのが重要

## 第4章　柔軟なインターフェースを作る
- オブジェクト指向アプリケーションはクラスから成り立つが、メソッドによって定義される
- そのため、設計ではオブジェクト間で受け渡されるメソッドについても考慮する必要があり、オブジェクトが何を知っているか（オブジェクトの責任）や誰を知っているか（依存関係）だけでなく、オブジェクトが互いにどのように会話するかも設計で考慮する必要がある
- オブジェクト間の会話はインターフェースを介して行われる
- クラスは単一の責任を果たすために存在するがメソッド自体はいくつも存在する
- クラスの責任を外部へ公開するメソッドはパブリックであり、内部でしか使用しないものはプライベートなメソッドである
- パブリックインターフェース
  - クラスの主要な責任を明らかにする
  - 外部から実行されることが想定される
  - 気まぐれに変更されない
  - 他者がそこに依存しても安全
  - テストで完全に文書化されている
- プライベートインターフェース
  - 実装の詳細に関わる
  - 他のオブジェクトから送られてくることは想定されてない
  - どんな理由でも変更されうる
  - 他者がそこに依存するのは危険
  - テストでは言及されないこともある
- 良いパブリックインターフェースは想定外の変更に対するコストを下げ、よくないパブリックインターフェースはコストを上げる
- クラスに基づく設計からメッセージに基づく設計への移行、「このクラスが必要なのは知っているが、これは何をすべきなのだろうか？」から「このメッセージを送る必要があるが、誰が応答するべきなのだろうか？」に変えることが、柔軟なアプリケーションを生み出すことに繋がる
- オブジェクトが存在するからメッセージを送るのではなく、メッセージを送るためにオブジェクトは存在する
- 「どのように」ではなく「何を」を頼めるようにすること、「どのように」は相手を信頼して任せることで、コンテキストに縛り付けられることなく共同作業ができるようになる
- デメテルの法則
  - オブジェクトを疎結合にするためのコーディング規則の集まり
  - メソッドチェーンが長くなりすぎると、どのように手に入れたらいいのかを知っている、ということになり、「何を求めているのか」以上のことを知ってしまっていることになる。すなわち密結合となってしまう
  - そうすると、メソッドチェーンのどこかで起こる関係のない変更によって、呼び出し元も自ずと変更しなければならなくなる
  - これはパブリックインターフェースが欠けているオブジェクトがあるのではないかというヒントになるため、デメテルに耳を傾けることが必要

## 第5章　ダックタイピングでコストを削減する
- 「もしオブジェクトがダックのように鳴き、ダックのように歩くならば、そのクラスが何であれ、それはダックである」
- 具象的なコードは理解は簡単だが拡張にはコストが伴う
- 抽象的なコードは最初の分かりにくさはあるものの、一度理解すれば変更しやすい
- ダックタイプを使うことでコードは具象的なものから抽象的なものへと変わっていく
- ダックタイプを見つけるために
  - 隠れたダックを認識する
    - クラスで分岐するcase文
      - case文が定義されているときは、「その引数のそれぞれから望むものは何だろうか？」を自問し、送るべきメッセージからダックタイプを定義する
    - `kind_of?`と`is_a?`
      - これらはクラスを確認するメソッドなので、case文の時と同様にダックタイプを定義することができる
    - `respond_to?`
      - 持っているメソッドを確認するメソッドだが、これもクラスに固く結びついているためダックタイプを定義できる
  - これらを使って分岐することは、「あなたが誰なのか知っている。なぜならあなたが何をするかを知っているから」と言っているも同然であり、オブジェクトへの信頼が欠けていることを表している
  - ダックタイピングは動的型付けの上に成り立つ
  - ダックタイピングはパブリックインターフェースを特定のクラスから切り離し、何であるかではなく何をするかによって定義される仮想の型を作る

## 第6章　継承によって振る舞いを獲得する
- 継承とは根本的には「メッセージの自動委譲」の仕組みであり、理解されなかったメッセージに対して転送経路を定義するもの
- クラスによる継承では、サブクラスを作ることによって継承は定義され、メッセージはサブクラスからスーパークラ明日へと転送される
- Rubyは単一継承であり、サブクラスは親となるスーパークラスを一つしか持つことができない、逆にスーパークラスは複数のサブクラスを持つことができる
- 抽象クラスはサブクラスが作られるために存在し、サブクラス間で共有される振る舞いの共通の格納場所を提供する。そしてサブクラスがそれぞれに特化したものを用意する
- 設計の戦略を決める際、一般的に有用なのは「もし間違っているとすれば何が起こるだろうか？」と自問すること
- 新たな継承の階層構造へとリファクタリングをするときには、抽象を昇格できるようにコードを構成すべきであり、具象を降格するような構成にはすべきでない
- サブクラスに必ず実装するように用意することで、もし用意されてない場合には有益なエラーメッセージを提供してくれる
  - `raise NotImplementedError`
- 抽象スーパークラスはテンプレートメソッドパターンを使うことで、その継承者に専門的に特化するよう促す
- そしてフックメソッドを使うことでsuperの送信を強制せずとも、継承者がスーパークラスに特化できるようにする

## 第7章　モジュールでロールの振る舞いを共有する
- 名前をつけてメソッドのグループを定義する方法が備わっていて、これはクラスとは独立してどんなオブジェクトにも混ぜ入れることができる、これをRubyではモジュールと呼ぶ
- オブジェクトが応答できるメッセージの集合には以下4種類のメッセージが含まれる
  - 自身が実装するメッセージ
  - 自身より上の階層のすべてのオブジェクトで実装されるメッセージ
  - 自身に追加されるすべてのモジュールで実装されるメッセージ
  - 自身より上の階層のオブジェクトに追加される、すべてのモジュールで実装されるメッセージ
- メソッド探索の仕組み
  - オブジェクトがメッセージを受け取ると、まずはクラスを見に行き、合致するメソッドを探しにいく
  - このクラスがそのメッセージを実装していなければ、スーパークラスへの探索に移る
  - これを行い、最終的にはスーパークラスの頂点にたどり着くまで続く
  - モジュールをインクルードすると、メソッドパス的にはモジュールはインクルードしたクラスの上階層に直接追加される
- リスコフの原則
  -  システムが正常であるためには、派生型は上位型と置換可能でなければならない
