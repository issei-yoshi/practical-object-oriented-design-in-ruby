## 第2章　単一責任のクラスを設計する
- メソッドをグループに分けてクラスにまとめる
  - クラスベースのオブジェクト指向言語ではメソッドはクラス内に定義される
  - PJの初期段階では正しくグループ分けすることはできないもの
  - 変更が必要な日が来たときに変更できるかどうかはアプリケーションの設計によって行きまる
  - 設計とはアプリケーションの可変性を保つために技巧を凝らすこと、決して完璧を目指すための行為ではない
- 変更が簡単なようにコードを組成する
  - 簡単という概念は以下の定義
    - 変更は副作用をもたらさない
    - 変更の要件が小さければコードの変更も相応して小さい
    - 既存のコードは簡単に再利用できる
    - 最も簡単な変更方法はコードの追加、追加するコードはそれ自体が変更することが容易なもの
  - 各コードには次の性質が伴うべき
    - 見通しが良い(Transparent)
      - 変更がもたらす影響が明白
    - 合理性(Reasonable)
      - かかるコストは変更がもたらす利益に相応しい
    - 利用性が高い(Usable)
      - 新しい環境、予期していなかった環境でも再利用可能
    - 模範的(Examplary)
      - コードに変更を加える人が品質を自然と保つようなコードになっている
  - これらの性質を兼ね備えたコードは今現時点でのニーズを満たすだけでなく、将来的なニーズを満たすように変更を加えることが可能
- なぜ単一責任が重要なのか?
  - 変更が簡単なアプリケーションは再利用が簡単なクラスから構成されており、必要な部品だけを選んで組み立てることができる
  - 一方で2つ以上の責任を持つクラスは、責任が互いに結合しすぎてしまうため、簡単に再利用することが難しい
  - クラスが実際に何をしているかを定めるためには1文でクラスについて説明することであり、もし「それと」という言葉が含まれているのであればそれは2つ以上の責任を負っていることになる
  - 「今何もしないことの将来的なコストはどれくらいだろうか？」と自問自答し、現時点での要件と未来の可能性の相互間のトレードオフを理解すること、そしてコストが最小になる決断を下すことが重要
- 変更を歓迎するコードを書くために
  - データではなく振る舞いに依存する
    - インスタンス変数を隠蔽する
      - Rubyで言えばattr_reader等で隠蔽できる
      - そうすることで直接インスタンス変数を参照するよりもDRYなコードにできる（多くの箇所を変更する必要はない）
      - 隠蔽することによって予期せぬ変更がコード影響を与えることを防ぐ
    - データ構造を隠蔽する
      - インスタンス変数が複雑なデータ構造を含んでいる場合、インスタンス変数を隠蔽するだけでは不十分
      - 何かしようとした時に、何のデータが複雑なデータ構造の、どこのインデックスにあるかを知っている必要がある
        - 配列の構造が変わったり、ハッシュに変わったりすると、これを使用している箇所から全体にバグを生んでしまう
      - RubyではStructクラスを使うことで構造を包み隠すことができるため、複雑なデータ構造に関する知識は別メソッドに逃すことで、外部データの構造変更に強くなる + コードの可読性も上がる
- あらゆる箇所を単一責任にする
  - メソッドもクラスのように単一責任巣しておくことで、メソッドの変更も再利用も簡単にすることができる
  - メソッドが単一の責任を持つようにすることで、、
    - 隠蔽されていた性質を明らかにする
    - コメントをする必要がない
    - 再利用を促進する
    - 他のクラスへの移動が簡単
